"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/core/index.ts








var _common = require('@vue-macros/common');



var _compilerdom = require('@vue/compiler-dom');
var STYLEX_CREATE = "_stylex_create";
var STYLEX_ATTRS = "_stylex_attrs";
function transformDirective(s) {
  return (node) => {
    if (!(node.type === 1)) return;
    const i = node.props.findIndex(
      (item) => item.type === 7 && item.rawName === "v-stylex"
    );
    if (i === -1) return;
    const directiveVStyleX = node.props[i];
    if (_optionalChain([directiveVStyleX, 'access', _ => _.exp, 'optionalAccess', _2 => _2.type]) !== 4)
      throw new Error("`v-stylex` must be passed a expression");
    const hasColon = directiveVStyleX.exp.content.startsWith("(") && directiveVStyleX.exp.content.endsWith(")");
    const prefix = hasColon ? "" : "(";
    const postfix = hasColon ? "" : ")";
    if (directiveVStyleX.exp.content.includes(STYLEX_ATTRS)) {
      _optionalChain([s, 'optionalAccess', _3 => _3.overwrite, 'call', _4 => _4(
        directiveVStyleX.loc.start.offset,
        directiveVStyleX.loc.end.offset,
        `v-bind="${directiveVStyleX.exp.content}"`
      )]);
      return;
    }
    _optionalChain([s, 'optionalAccess', _5 => _5.overwrite, 'call', _6 => _6(
      directiveVStyleX.loc.start.offset,
      directiveVStyleX.loc.end.offset,
      `v-bind="${STYLEX_ATTRS}${prefix}${directiveVStyleX.exp.content}${postfix}"`
    )]);
  };
}
function transformDefineStyleX(code, id) {
  if (!code.includes(_common.DEFINE_STYLEX)) return;
  const sfc = _common.parseSFC.call(void 0, code, id);
  const { scriptSetup, getSetupAst, template } = sfc;
  if (!scriptSetup || !template) return;
  let scriptOffset;
  const setupOffset = scriptSetup.loc.start.offset;
  const s = new (0, _common.MagicStringAST)(code);
  const normalScript = _common.addNormalScript.call(void 0, sfc, s);
  function moveToScript(decl, prefix = "") {
    if (scriptOffset === void 0) scriptOffset = normalScript.start();
    const text = `
${prefix}${s.sliceNode(decl, { offset: setupOffset })}`;
    s.appendRight(scriptOffset, text);
    s.removeNode(decl, { offset: setupOffset });
  }
  const setupAST = getSetupAst();
  _common.walkAST.call(void 0, setupAST, {
    enter(node) {
      if (node.type !== "VariableDeclaration") return;
      node.declarations.forEach((decl) => {
        if (!_common.isCallOf.call(void 0, decl.init, _common.DEFINE_STYLEX)) return;
        s.overwriteNode(decl.init.callee, STYLEX_CREATE, {
          offset: setupOffset
        });
      });
      moveToScript(node);
    }
  });
  if (scriptOffset !== void 0) normalScript.end();
  const ctx = _compilerdom.createTransformContext.call(void 0, template.ast, {
    nodeTransforms: [transformDirective(s)]
  });
  _compilerdom.traverseNode.call(void 0, template.ast, ctx);
  s.appendRight(
    setupOffset,
    `
import { create as ${STYLEX_CREATE}, attrs as ${STYLEX_ATTRS} } from '@stylexjs/stylex'`
  );
  return _common.generateTransform.call(void 0, s, id);
}



exports.transformDefineStyleX = transformDefineStyleX;
