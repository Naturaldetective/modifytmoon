'use strict';

var astUtils = require('@typescript-eslint/utils/ast-utils');
var utils = require('@typescript-eslint/utils');
var Graphemer = require('graphemer');
require('@typescript-eslint/type-utils');
var scopeManager = require('@typescript-eslint/scope-manager');
var jsRules = require('@stylistic/eslint-plugin-js');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _scopeManager;
class UnusedVarsVisitor extends scopeManager.Visitor {
  // readonly #unusedVariables = new Set<TSESLint.Scope.Variable>();
  constructor(context) {
    super({
      visitChildrenEvenIfSelectorExists: true
    });
    __privateAdd(this, _scopeManager, void 0);
    // #endregion HELPERS
    // #region VISITORS
    // NOTE - This is a simple visitor - meaning it does not support selectors
    __publicField(this, "ClassDeclaration", this.visitClass);
    __publicField(this, "ClassExpression", this.visitClass);
    __publicField(this, "FunctionDeclaration", this.visitFunction);
    __publicField(this, "FunctionExpression", this.visitFunction);
    __publicField(this, "MethodDefinition", this.visitSetter);
    __publicField(this, "Property", this.visitSetter);
    __publicField(this, "TSCallSignatureDeclaration", this.visitFunctionTypeSignature);
    __publicField(this, "TSConstructorType", this.visitFunctionTypeSignature);
    __publicField(this, "TSConstructSignatureDeclaration", this.visitFunctionTypeSignature);
    __publicField(this, "TSDeclareFunction", this.visitFunctionTypeSignature);
    __publicField(this, "TSEmptyBodyFunctionExpression", this.visitFunctionTypeSignature);
    __publicField(this, "TSFunctionType", this.visitFunctionTypeSignature);
    __publicField(this, "TSMethodSignature", this.visitFunctionTypeSignature);
    __privateSet(this, _scopeManager, utils.ESLintUtils.nullThrows(
      context.getSourceCode().scopeManager,
      "Missing required scope manager"
    ));
  }
  static collectUnusedVariables(context) {
    const program = context.getSourceCode().ast;
    const cached = this.RESULTS_CACHE.get(program);
    if (cached)
      return cached;
    const visitor = new this(context);
    visitor.visit(program);
    const unusedVars = visitor.collectUnusedVariables(
      visitor.getScope(program)
    );
    this.RESULTS_CACHE.set(program, unusedVars);
    return unusedVars;
  }
  collectUnusedVariables(scope, unusedVariables = /* @__PURE__ */ new Set()) {
    for (const variable of scope.variables) {
      if (
        // skip function expression names,
        scope.functionExpressionScope || variable.eslintUsed || variable instanceof scopeManager.ImplicitLibVariable || isExported(variable) || isMergableExported(variable) || isUsedVariable(variable)
      )
        continue;
      unusedVariables.add(variable);
    }
    for (const childScope of scope.childScopes)
      this.collectUnusedVariables(childScope, unusedVariables);
    return unusedVariables;
  }
  // #region HELPERS
  getScope(currentNode) {
    const inner = currentNode.type !== utils.AST_NODE_TYPES.Program;
    let node = currentNode;
    while (node) {
      const scope = __privateGet(this, _scopeManager).acquire(node, inner);
      if (scope) {
        if (scope.type === scopeManager.ScopeType.functionExpressionName)
          return scope.childScopes[0];
        return scope;
      }
      node = node.parent;
    }
    return __privateGet(this, _scopeManager).scopes[0];
  }
  markVariableAsUsed(variableOrIdentifierOrName, parent) {
    if (typeof variableOrIdentifierOrName !== "string" && !("type" in variableOrIdentifierOrName)) {
      variableOrIdentifierOrName.eslintUsed = true;
      return;
    }
    let name;
    let node;
    if (typeof variableOrIdentifierOrName === "string") {
      name = variableOrIdentifierOrName;
      node = parent;
    } else {
      name = variableOrIdentifierOrName.name;
      node = variableOrIdentifierOrName;
    }
    let currentScope = this.getScope(node);
    while (currentScope) {
      const variable = currentScope.variables.find(
        (scopeVar) => scopeVar.name === name
      );
      if (variable) {
        variable.eslintUsed = true;
        return;
      }
      currentScope = currentScope.upper;
    }
  }
  visitClass(node) {
    const scope = this.getScope(node);
    for (const variable of scope.variables) {
      if (variable.identifiers[0] === scope.block.id) {
        this.markVariableAsUsed(variable);
        return;
      }
    }
  }
  visitFunction(node) {
    const scope = this.getScope(node);
    const variable = scope.set.get("arguments");
    if (variable?.defs.length === 0)
      this.markVariableAsUsed(variable);
  }
  visitFunctionTypeSignature(node) {
    for (const param of node.params) {
      this.visitPattern(param, (name) => {
        this.markVariableAsUsed(name);
      });
    }
  }
  visitSetter(node) {
    if (node.kind === "set") {
      for (const param of node.value.params) {
        this.visitPattern(param, (id) => {
          this.markVariableAsUsed(id);
        });
      }
    }
  }
  ForInStatement(node) {
    let idOrVariable;
    if (node.left.type === utils.AST_NODE_TYPES.VariableDeclaration) {
      const variable = __privateGet(this, _scopeManager).getDeclaredVariables(node.left)[0];
      if (!variable)
        return;
      idOrVariable = variable;
    }
    if (node.left.type === utils.AST_NODE_TYPES.Identifier)
      idOrVariable = node.left;
    if (idOrVariable == null)
      return;
    let body = node.body;
    if (node.body.type === utils.AST_NODE_TYPES.BlockStatement) {
      if (node.body.body.length !== 1)
        return;
      body = node.body.body[0];
    }
    if (body.type !== utils.AST_NODE_TYPES.ReturnStatement)
      return;
    this.markVariableAsUsed(idOrVariable);
  }
  Identifier(node) {
    const scope = this.getScope(node);
    if (scope.type === utils.TSESLint.Scope.ScopeType.function && node.name === "this") {
      if ("params" in scope.block && scope.block.params.includes(node))
        this.markVariableAsUsed(node);
    }
  }
  TSEnumDeclaration(node) {
    const scope = this.getScope(node);
    for (const variable of scope.variables)
      this.markVariableAsUsed(variable);
  }
  TSMappedType(node) {
    this.markVariableAsUsed(node.typeParameter.name);
  }
  TSModuleDeclaration(node) {
    if (node.global === true)
      this.markVariableAsUsed("global", node.parent);
  }
  TSParameterProperty(node) {
    let identifier = null;
    switch (node.parameter.type) {
      case utils.AST_NODE_TYPES.AssignmentPattern:
        if (node.parameter.left.type === utils.AST_NODE_TYPES.Identifier)
          identifier = node.parameter.left;
        break;
      case utils.AST_NODE_TYPES.Identifier:
        identifier = node.parameter;
        break;
    }
    if (identifier)
      this.markVariableAsUsed(identifier);
  }
  // #endregion VISITORS
}
_scopeManager = new WeakMap();
__publicField(UnusedVarsVisitor, "RESULTS_CACHE", /* @__PURE__ */ new WeakMap());
function isInside(inner, outer) {
  return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
}
function isSelfReference(ref, nodes) {
  let scope = ref.from;
  while (scope) {
    if (nodes.has(scope.block))
      return true;
    scope = scope.upper;
  }
  return false;
}
const MERGABLE_TYPES = /* @__PURE__ */ new Set([
  utils.AST_NODE_TYPES.TSInterfaceDeclaration,
  utils.AST_NODE_TYPES.TSTypeAliasDeclaration,
  utils.AST_NODE_TYPES.TSModuleDeclaration,
  utils.AST_NODE_TYPES.ClassDeclaration,
  utils.AST_NODE_TYPES.FunctionDeclaration
]);
function isMergableExported(variable) {
  for (const def of variable.defs) {
    if (def.type === utils.TSESLint.Scope.DefinitionType.Parameter)
      continue;
    if (MERGABLE_TYPES.has(def.node.type) && def.node.parent?.type === utils.AST_NODE_TYPES.ExportNamedDeclaration || def.node.parent?.type === utils.AST_NODE_TYPES.ExportDefaultDeclaration)
      return true;
  }
  return false;
}
function isExported(variable) {
  return variable.defs.some((definition) => {
    let node = definition.node;
    if (node.type === utils.AST_NODE_TYPES.VariableDeclarator)
      node = node.parent;
    else if (definition.type === utils.TSESLint.Scope.DefinitionType.Parameter)
      return false;
    return node.parent.type.indexOf("Export") === 0;
  });
}
function isUsedVariable(variable) {
  function getFunctionDefinitions(variable2) {
    const functionDefinitions = /* @__PURE__ */ new Set();
    variable2.defs.forEach((def) => {
      if (def.type === utils.TSESLint.Scope.DefinitionType.FunctionName)
        functionDefinitions.add(def.node);
      if (def.type === utils.TSESLint.Scope.DefinitionType.Variable && (def.node.init?.type === utils.AST_NODE_TYPES.FunctionExpression || def.node.init?.type === utils.AST_NODE_TYPES.ArrowFunctionExpression))
        functionDefinitions.add(def.node.init);
    });
    return functionDefinitions;
  }
  function getTypeDeclarations(variable2) {
    const nodes = /* @__PURE__ */ new Set();
    variable2.defs.forEach((def) => {
      if (def.node.type === utils.AST_NODE_TYPES.TSInterfaceDeclaration || def.node.type === utils.AST_NODE_TYPES.TSTypeAliasDeclaration)
        nodes.add(def.node);
    });
    return nodes;
  }
  function getModuleDeclarations(variable2) {
    const nodes = /* @__PURE__ */ new Set();
    variable2.defs.forEach((def) => {
      if (def.node.type === utils.AST_NODE_TYPES.TSModuleDeclaration)
        nodes.add(def.node);
    });
    return nodes;
  }
  function isInsideOneOf(ref, nodes) {
    for (const node of nodes) {
      if (isInside(ref.identifier, node))
        return true;
    }
    return false;
  }
  function getRhsNode(ref, prevRhsNode) {
    function isInLoop(node) {
      let currentNode = node;
      while (currentNode) {
        if (utils.ASTUtils.isFunction(currentNode))
          break;
        if (utils.ASTUtils.isLoop(currentNode))
          return true;
        currentNode = currentNode.parent;
      }
      return false;
    }
    const id = ref.identifier;
    const parent = id.parent;
    const grandparent = parent.parent;
    const refScope = ref.from.variableScope;
    const varScope = ref.resolved.scope.variableScope;
    const canBeUsedLater = refScope !== varScope || isInLoop(id);
    if (prevRhsNode && isInside(id, prevRhsNode))
      return prevRhsNode;
    if (parent.type === utils.AST_NODE_TYPES.AssignmentExpression && grandparent.type === utils.AST_NODE_TYPES.ExpressionStatement && id === parent.left && !canBeUsedLater)
      return parent.right;
    return null;
  }
  function isReadForItself(ref, rhsNode2) {
    function isInsideOfStorableFunction(id2, rhsNode3) {
      function getUpperFunction(node) {
        let currentNode = node;
        while (currentNode) {
          if (utils.ASTUtils.isFunction(currentNode))
            return currentNode;
          currentNode = currentNode.parent;
        }
        return null;
      }
      function isStorableFunction(funcNode2, rhsNode4) {
        let node = funcNode2;
        let parent2 = funcNode2.parent;
        while (parent2 && isInside(parent2, rhsNode4)) {
          switch (parent2.type) {
            case utils.AST_NODE_TYPES.SequenceExpression:
              if (parent2.expressions[parent2.expressions.length - 1] !== node)
                return false;
              break;
            case utils.AST_NODE_TYPES.CallExpression:
            case utils.AST_NODE_TYPES.NewExpression:
              return parent2.callee !== node;
            case utils.AST_NODE_TYPES.AssignmentExpression:
            case utils.AST_NODE_TYPES.TaggedTemplateExpression:
            case utils.AST_NODE_TYPES.YieldExpression:
              return true;
            default:
              if (parent2.type.endsWith("Statement") || parent2.type.endsWith("Declaration")) {
                return true;
              }
          }
          node = parent2;
          parent2 = parent2.parent;
        }
        return false;
      }
      const funcNode = getUpperFunction(id2);
      return !!funcNode && isInside(funcNode, rhsNode3) && isStorableFunction(funcNode, rhsNode3);
    }
    const id = ref.identifier;
    const parent = id.parent;
    const grandparent = parent.parent;
    return ref.isRead() && (parent.type === utils.AST_NODE_TYPES.AssignmentExpression && grandparent.type === utils.AST_NODE_TYPES.ExpressionStatement && parent.left === id || parent.type === utils.AST_NODE_TYPES.UpdateExpression && grandparent.type === utils.AST_NODE_TYPES.ExpressionStatement || !!rhsNode2 && isInside(id, rhsNode2) && !isInsideOfStorableFunction(id, rhsNode2));
  }
  const functionNodes = getFunctionDefinitions(variable);
  const isFunctionDefinition = functionNodes.size > 0;
  const typeDeclNodes = getTypeDeclarations(variable);
  const isTypeDecl = typeDeclNodes.size > 0;
  const moduleDeclNodes = getModuleDeclarations(variable);
  const isModuleDecl = moduleDeclNodes.size > 0;
  let rhsNode = null;
  return variable.references.some((ref) => {
    const forItself = isReadForItself(ref, rhsNode);
    rhsNode = getRhsNode(ref, rhsNode);
    return ref.isRead() && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes)) && !(isTypeDecl && isInsideOneOf(ref, typeDeclNodes)) && !(isModuleDecl && isSelfReference(ref, moduleDeclNodes));
  });
}

const createRule = utils.ESLintUtils.RuleCreator(
  (name) => `https://eslint.style/rules/ts/${name}`
);

let splitter;
function isASCII(value) {
  return /^[\u0020-\u007F]*$/u.test(value);
}
function getStringLength(value) {
  if (isASCII(value))
    return value.length;
  splitter ?? (splitter = new Graphemer());
  return splitter.countGraphemes(value);
}

const {
  applyDefault,
  deepMerge,
  isObjectNotArray,
  getParserServices,
  nullThrows,
  NullThrowsReasons
} = utils.ESLintUtils;

const getESLintCoreRule = (ruleId) => {
  if (ruleId in jsRules.rules)
    return jsRules.rules[ruleId];
  throw new Error(`Failed to find core rule ${ruleId}, this is an internal bug of @stylistic/eslint-plugin-ts`);
};

const baseRule = getESLintCoreRule("block-spacing");
var blockSpacing = createRule({
  name: "block-spacing",
  meta: {
    type: "layout",
    docs: {
      description: "Disallow or enforce spaces inside of blocks after opening block and before closing block",
      extendsBaseRule: true
    },
    fixable: "whitespace",
    hasSuggestions: baseRule.meta.hasSuggestions,
    schema: baseRule.meta.schema,
    messages: baseRule.meta.messages
  },
  defaultOptions: ["always"],
  create(context, [whenToApplyOption]) {
    const sourceCode = context.getSourceCode();
    const baseRules = baseRule.create(context);
    const always = whenToApplyOption !== "never";
    const messageId = always ? "missing" : "extra";
    function getOpenBrace(node) {
      return sourceCode.getFirstToken(node, {
        filter: (token) => token.type === utils.AST_TOKEN_TYPES.Punctuator && token.value === "{"
      });
    }
    function isValid(left, right) {
      return !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetween(left, right) === always;
    }
    function checkSpacingInsideBraces(node) {
      const openBrace = getOpenBrace(node);
      const closeBrace = sourceCode.getLastToken(node);
      const firstToken = sourceCode.getTokenAfter(openBrace, {
        includeComments: true
      });
      const lastToken = sourceCode.getTokenBefore(closeBrace, {
        includeComments: true
      });
      if (openBrace.type !== utils.AST_TOKEN_TYPES.Punctuator || openBrace.value !== "{" || closeBrace.type !== utils.AST_TOKEN_TYPES.Punctuator || closeBrace.value !== "}" || firstToken === closeBrace)
        return;
      if (!always && firstToken.type === utils.AST_TOKEN_TYPES.Line)
        return;
      if (!isValid(openBrace, firstToken)) {
        let loc = openBrace.loc;
        if (messageId === "extra") {
          loc = {
            start: openBrace.loc.end,
            end: firstToken.loc.start
          };
        }
        context.report({
          node,
          loc,
          messageId,
          data: {
            location: "after",
            token: openBrace.value
          },
          fix(fixer) {
            if (always)
              return fixer.insertTextBefore(firstToken, " ");
            return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
          }
        });
      }
      if (!isValid(lastToken, closeBrace)) {
        let loc = closeBrace.loc;
        if (messageId === "extra") {
          loc = {
            start: lastToken.loc.end,
            end: closeBrace.loc.start
          };
        }
        context.report({
          node,
          loc,
          messageId,
          data: {
            location: "before",
            token: closeBrace.value
          },
          fix(fixer) {
            if (always)
              return fixer.insertTextAfter(lastToken, " ");
            return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
          }
        });
      }
    }
    return {
      ...baseRules,
      // This code worked "out of the box" for interface and type literal
      // Enums were very close to match as well, the only reason they are not is that was that enums don't have a body node in the parser
      // So the opening brace punctuator starts in the middle of the node - `getFirstToken` in
      // the base rule did not filter for the first opening brace punctuator
      TSInterfaceBody: baseRules.BlockStatement,
      TSTypeLiteral: baseRules.BlockStatement,
      TSEnumDeclaration: checkSpacingInsideBraces
    };
  }
});

exports.NullThrowsReasons = NullThrowsReasons;
exports.blockSpacing = blockSpacing;
exports.createRule = createRule;
exports.deepMerge = deepMerge;
exports.getESLintCoreRule = getESLintCoreRule;
exports.getStringLength = getStringLength;
exports.nullThrows = nullThrows;
